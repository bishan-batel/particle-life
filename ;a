use std::{f32::consts::TAU, sync::Arc};

use macroquad::prelude::*;

#[derive(Debug, Clone)]
pub struct SimulationSettings {
    pub species_relations: Vec<Vec<f32>>,
    pub species: Vec<Color>,
    pub particle_size: f32,
    pub interaction_dist: f32,
    pub friction: f32,
}

impl SimulationSettings {
    fn species_color(&self, species: Species) -> Option<Color> {
        self.species.get(species.0).copied()
    }

    pub fn interaction(&self, first: Species, second: Species) -> f32 {
        self.species_relations[first.0][second.0]
    }
}

#[derive(Debug, Copy, Clone)]
pub struct Species(usize);

#[derive(Debug, Clone)]
pub struct Particle {
    position: Vec2,
    velocity: Vec2,
    species: Species,
    settings: Arc<SimulationSettings>,
    bounds: (Vec2, Vec2),
}

impl Particle {
    pub fn random(settings: Arc<SimulationSettings>, min: Vec2, max: Vec2) -> Particle {
        Particle {
            species: Species(rand::gen_range(0, settings.species.len())),
            velocity: 100. * Vec2::from_angle(rand::gen_range(0., TAU)),
            position: vec2(rand::gen_range(min.x, max.x), rand::gen_range(min.y, max.y)),
            bounds: (min, max),
            settings,
        }
    }

    pub fn interact(&mut self, dt: f32, other: &[Particle]) {
        let interact_dist = self.settings.interaction_dist;
        let interact_dist2 = interact_dist.powi(2);

        let mut force = vec2(0., 0.);

        for other in other.iter() {
            let to_other = other.position - self.position;
            let dist = to_other.length_squared();

            if dist < 1E-3 {
                continue;
            }

            if dist > interact_dist2 {
                continue;
            }

            let dist = dist.sqrt();
            let dir = to_other / dist;

            force += dir
                * self.settings.interaction(self.species, other.species)
                * (interact_dist / dist).clamp(0., 1.);

            if dist < self.settings.particle_size * 2. {
                let new_position =
                    (self.position + to_other / 2.) - dir * self.settings.particle_size;
                // self.position = new_position;
                force += (new_position - self.position) * 2.;
            }

            // force -= (-dist).exp() * (self.settings.particle_size * 2. - dist);
        }

        self.velocity += 100. * force * dt;
    }

    pub fn integrate(&mut self, dt: f32) {
        self.position += self.velocity * dt;
        self.position = self.position.clamp(self.bounds.0, self.bounds.1);

        self.velocity += (-self.position).normalize() * self.position.length().sqrt() / 10.;
        self.velocity *= self.settings.friction;
    }

    pub fn draw(&self) {
        draw_circle(
            self.position.x,
            self.position.y,
            self.settings.particle_size,
            self.settings.species_color(self.species).unwrap(),
        );
    }

    pub fn species(&self) -> Species {
        self.species
    }
}
